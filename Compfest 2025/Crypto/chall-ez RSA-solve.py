import math

def inverse(a, m):
    """Extended Euclidean Algorithm to find modular inverse"""
    def extended_gcd(a, b):
        if a == 0:
            return b, 0, 1
        else:
            gcd, x, y = extended_gcd(b % a, a)
            return gcd, y - (b // a) * x, x
    
    gcd, x, _ = extended_gcd(a, m)
    if gcd != 1:
        raise ValueError("Modular inverse does not exist")
    else:
        return x % m

def long_to_bytes(n):
    """Convert a long integer to bytes"""
    if n == 0:
        return b'\x00'
    
    # Convert to hex and then to bytes
    hex_str = hex(n)[2:]  # Remove '0x' prefix
    if len(hex_str) % 2 == 1:
        hex_str = '0' + hex_str
    return bytes.fromhex(hex_str)

n = 105375332609681406515521070043624487782870196469191202161434435531817940797270096886963495613362630149726295573449318680766414229677517682441830990791937099476820215035329281663818952921640911864146786915767893480415096397401467294479247404193884100343032732555022965900945086176438781154250207246166555647819
o1 = 77633598805092640252724107910395222743707418498331661189888724505381859694624522363159360564093918240382178585305319104811978787648604211175237899879841354634012079538469832859655067901694047617975823882351549659190376576638974977699045922795589181771284109834805293637783792031515473496804956462795626934818
o2 = 47429151844475742641042649495407207662566851803789329455756849511508428188444666235575337458509278378043440668303749169805120807459770548206797504115709846618485098694340179746812314900747328860355887054449308844370972363371972119596004863894202184305426870041561045629249134118889938654187837181030481512607
e1 = 186867715974359025539631582285150663971
e2 = 337065940616672019740199340023447546329
ct = 16127635971745761249117457383238357500818225865528781227818178295767094522191015256304698417447261196635354815589533608289075225290218976735930144917429170204631913040282911740200678626608196556229117931217102495952857640280769261620708029036539274328113707476723320511409928978108912915377499577509818504791

# Step 1: Factor n
e1_e2 = e1 * e2
pow_minus3 = pow(-3, e1_e2, n)
pow_5 = pow(5, e1_e2, n)
term1 = pow(o1, e2, n)
term2 = pow(o2, e1, n)
X_mod_n = (term1 * pow_minus3 - term2 * pow_5) % n
p = math.gcd(X_mod_n, n)
q = n // p

# Step 2: Decrypt the intermediate value
e = 65537
phi = (p - 1) * (q - 1)
d = inverse(e, phi)
dec_intermediate = pow(ct, d, n)

# Step 3: Recover the flag
inv_o1 = inverse(o1, n)
inv_o2 = inverse(o2, n)
m = (dec_intermediate * inv_o1 * inv_o2) % n

flag = long_to_bytes(m).decode('latin-1')

print(f"The flag is: {flag}")