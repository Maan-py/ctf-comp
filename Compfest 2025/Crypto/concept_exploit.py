from binascii import hexlify, unhexlify

# Conceptual demonstration of Padding Oracle Attack
# This shows how the attack works without needing the actual Crypto library

print("üê£ Padding Oracle Attack - Conceptual Demonstration")
print("=" * 50)

# Simulate the challenge scenario
FLAG = b"COMPFEST17{REDACTED}"

print(f"Target flag: {FLAG.decode()}")
print(f"Flag length: {len(FLAG)} bytes")

# Simulate AES-CBC encryption with PKCS7 padding
def simulate_encryption(plaintext):
    """Simulate AES-CBC encryption with PKCS7 padding"""
    # Add PKCS7 padding
    block_size = 16
    padding_len = block_size - (len(plaintext) % block_size)
    padded = plaintext + bytes([padding_len] * padding_len)
    
    # Simulate IV + encrypted data
    iv = b'\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10'
    # In real scenario, this would be actual AES encryption
    encrypted = padded  # Simplified for demonstration
    
    return iv + encrypted

def simulate_padding_oracle(ciphertext_hex):
    """Simulate the padding oracle from the challenge"""
    try:
        # In real scenario, this would decrypt and check padding
        # For demonstration, we'll simulate valid/invalid padding
        ct = unhexlify(ciphertext_hex)
        if len(ct) % 16 == 0 and ct[-1] <= 16:
            return True  # Valid padding
        return False  # Invalid padding
    except:
        return False

# Get encrypted flag
encrypted_flag = simulate_encryption(FLAG)
encrypted_flag_hex = hexlify(encrypted_flag).decode()
print(f"\nEncrypted flag: {encrypted_flag_hex}")

# Demonstrate padding oracle attack concept
def demonstrate_padding_oracle_attack():
    """Demonstrate how padding oracle attack works"""
    print("\nüîç Padding Oracle Attack Process:")
    print("1. Get encrypted flag from server (option 3)")
    print("2. Use padding oracle to decrypt block by block")
    print("3. For each block, decrypt byte by byte from end to start")
    print("4. Use the oracle to test if padding is valid")
    
    print("\nüìã Attack Steps:")
    print("Step 1: Get encrypted flag using option 3")
    print("Step 2: For each block (except IV):")
    print("  - For each byte position (15 to 0):")
    print("    - Try all 256 possible values")
    print("    - Modify previous block to test padding")
    print("    - Use option 2 to test if padding is valid")
    print("    - If valid padding found, we found the correct byte")
    
    print("\nüéØ Key Insight:")
    print("- The server reveals if padding is valid through option 2")
    print("- Invalid padding causes 'Oops mesin pemecah telur rusak' error")
    print("- Valid padding allows us to decrypt the message")
    print("- We can use this oracle to decrypt the flag without knowing the key!")

# Show the actual exploit strategy
def show_exploit_strategy():
    print("\nüöÄ Exploit Strategy:")
    print("1. Connect to the challenge server")
    print("2. Use option 3 to get encrypted flag")
    print("3. Implement padding oracle attack:")
    print("   - Split ciphertext into blocks")
    print("   - For each block, decrypt byte by byte")
    print("   - Use option 2 as padding oracle")
    print("   - Reconstruct the original plaintext")
    print("4. Extract the flag from decrypted data")

demonstrate_padding_oracle_attack()
show_exploit_strategy()

print("\nüí° The Real Exploit Would:")
print("- Connect to the actual server")
print("- Use the padding oracle (option 2) to decrypt the flag")
print("- Handle the server responses properly")
print("- Decrypt the flag byte by byte using the oracle")

print(f"\nüéâ Expected Flag Format: COMPFEST17{{...}}")
print("The actual flag would be revealed by running the exploit against the real server!") 