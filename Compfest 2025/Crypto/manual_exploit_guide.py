print("ðŸ£ Manual Padding Oracle Exploit Guide")
print("=" * 50)

print("""
This challenge is vulnerable to a Padding Oracle Attack on AES-CBC.

ðŸ” VULNERABILITY ANALYSIS:
- The server uses AES-CBC encryption with PKCS7 padding
- Option 2 (decrypt) reveals whether padding is valid or not
- Invalid padding causes "Oops mesin pemecah telur rusak" error
- Valid padding allows decryption to succeed
- This creates a padding oracle that we can exploit

ðŸš€ EXPLOIT STEPS:

1. GET ENCRYPTED FLAG:
   - Run the challenge: python "chall-Ayam Enak Sekali copy.py"
   - Choose option 3: "Dapat telur rahasia"
   - Copy the hex output (this is the encrypted flag)

2. PADDING ORACLE ATTACK:
   - Split the encrypted flag into blocks (IV + ciphertext blocks)
   - For each ciphertext block (except IV):
     - Decrypt byte by byte from end to start
     - Use option 2 to test if padding is valid
     - Modify the previous block to control padding

3. ATTACK ALGORITHM:
   For each block C[i] with previous block C[i-1]:
     For each byte position j (15 to 0):
       For each guess g (0 to 255):
         - Modify C[i-1][j] = g âŠ• padding_length
         - Set known padding bytes in C[i-1]
         - Test with oracle (option 2)
         - If valid padding, we found the correct byte

4. RECONSTRUCT FLAG:
   - XOR decrypted bytes with original previous block
   - Remove PKCS7 padding
   - Extract the flag

ðŸ“‹ MANUAL EXPLOIT SCRIPT:
""")

print("""
# Example exploit script structure:

def padding_oracle_attack(encrypted_flag_hex):
    ct = bytes.fromhex(encrypted_flag_hex)
    iv = ct[:16]
    blocks = [ct[i:i+16] for i in range(16, len(ct), 16)]
    
    decrypted = b''
    for i, block in enumerate(blocks):
        prev_block = blocks[i-1] if i > 0 else iv
        decrypted_block = decrypt_block_with_oracle(block, prev_block)
        decrypted += decrypted_block
    
    return remove_padding(decrypted)

def decrypt_block_with_oracle(target_block, prev_block):
    decrypted = b''
    for byte_pos in range(15, -1, -1):
        padding_len = 16 - byte_pos
        for guess in range(256):
            # Create test ciphertext with modified padding
            test_prev = bytearray(prev_block)
            # Set known padding bytes
            for k in range(byte_pos + 1, 16):
                test_prev[k] = decrypted[15-k] ^ padding_len
            # Set current byte
            test_prev[byte_pos] = guess ^ padding_len
            
            # Test with oracle
            test_ct = bytes(test_prev) + target_block
            if test_padding_oracle(test_ct.hex()):
                decrypted = bytes([guess]) + decrypted
                break
    
    return decrypted
""")

print("""
ðŸŽ¯ KEY INSIGHTS:
- The server's error handling reveals padding validity
- We can decrypt without knowing the encryption key
- Each byte requires up to 256 oracle queries
- Total queries: ~256 * 16 * number_of_blocks

ðŸ”§ TOOLS NEEDED:
- Python with subprocess to interact with server
- Proper handling of server I/O
- Hex encoding/decoding utilities
- XOR operations for block manipulation

ðŸ’¡ TIPS:
- Start with a simple test case
- Verify oracle behavior with known plaintexts
- Handle edge cases (first block, last block)
- Be patient - the attack requires many queries
""")

print("""
ðŸŽ‰ EXPECTED RESULT:
The flag should be in format: COMPFEST17{...}

The actual flag will be revealed by running the complete
padding oracle attack against the challenge server.
""")

print("\n" + "="*50)
print("To run the actual exploit:")
print("1. Install pycryptodome: pip install pycryptodome")
print("2. Create the exploit script with proper server interaction")
print("3. Run against the challenge server")
print("4. Extract the flag from decrypted data") 