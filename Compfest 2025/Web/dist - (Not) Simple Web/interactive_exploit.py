import socket
import re
from Crypto.Util.number import long_to_bytes
import gmpy2

def connect_to_server(host='localhost', port=1234):
    """Connect to the server and get N, e, ct"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))
    
    # Receive initial messages
    data = sock.recv(4096).decode()
    print("Received:", data)
    
    # Extract N
    n_match = re.search(r'N:\s*(\d+)', data)
    if not n_match:
        print("Could not find N in response")
        return None, None, None
    
    N = int(n_match.group(1))
    print(f"N = {N}")
    
    # Send bound
    bound = str(2**2000)  # Very large bound to make d small
    print(f"Sending bound: {bound}")
    sock.send((bound + '\n').encode())
    
    # Receive e and ct
    data = sock.recv(4096).decode()
    print("Received:", data)
    
    # Extract e and ct
    e_match = re.search(r'e:\s*(\d+)', data)
    ct_match = re.search(r'ct:\s*(\d+)', data)
    
    if not e_match or not ct_match:
        print("Could not find e or ct in response")
        return N, None, None
    
    e = int(e_match.group(1))
    ct = int(ct_match.group(1))
    
    print(f"e = {e}")
    print(f"ct = {ct}")
    
    sock.close()
    return N, e, ct

def continued_fraction(e, n):
    """Compute continued fraction expansion of e/n"""
    cf = []
    while n:
        q, r = divmod(e, n)
        cf.append(q)
        e, n = n, r
    return cf

def convergents(cf):
    """Compute convergents from continued fraction"""
    convergents = []
    for i in range(len(cf)):
        num, den = 1, 0
        for j in range(i, -1, -1):
            num, den = den, num
            num += cf[j] * den
        convergents.append((num, den))
    return convergents

def wiener_attack(e, n):
    """Wiener's attack on RSA with small private exponent"""
    print("Attempting Wiener attack...")
    cf = continued_fraction(e, n)
    convergents_list = convergents(cf)
    
    for i, (k, d) in enumerate(convergents_list):
        if k == 0 or d == 0:
            continue
            
        # Check if this d could be the private key
        if e * d % k == 1:
            print(f"Found potential d: {d}")
            # Try to decrypt
            try:
                pt = pow(ct, d, n)
                flag = long_to_bytes(pt)
                if b'COMPFEST' in flag or b'flag' in flag.lower() or b'{' in flag:
                    print(f"SUCCESS! Flag: {flag}")
                    return flag
            except:
                continue
    
    print("Wiener attack failed")
    return None

def fermat_factor(n):
    """Fermat's factorization method for numbers with close factors"""
    print("Attempting Fermat factorization...")
    a = gmpy2.isqrt(n)
    if a * a == n:
        return a, a
    
    a += 1
    count = 0
    while count < 1000000:  # Limit iterations
        b2 = a * a - n
        b = gmpy2.isqrt(b2)
        if b * b == b2:
            p = a + b
            q = a - b
            print(f"Found factors: p={p}, q={q}")
            return p, q
        a += 1
        count += 1
    
    print("Fermat factorization failed")
    return None, None

def decrypt_with_factors(ct, e, p, q):
    """Decrypt using factors p and q"""
    n = p * q
    # For this challenge: phi = (p²-1)(q²-1)
    phi = (p*p - 1) * (q*q - 1)
    d = pow(e, -1, phi)
    pt = pow(ct, d, n)
    return long_to_bytes(pt)

def main():
    print("=== RSA Custom Parameter Interactive Exploit ===")
    print()
    
    # Get server details
    host = input("Enter server host (default: localhost): ").strip() or 'localhost'
    port = int(input("Enter server port (default: 1234): ").strip() or '1234')
    
    print(f"\nConnecting to {host}:{port}...")
    
    # Connect and get parameters
    N, e, ct = connect_to_server(host, port)
    
    if N is None:
        print("Failed to connect to server")
        return
    
    print(f"\nParameters obtained:")
    print(f"N = {N}")
    print(f"e = {e}")
    print(f"ct = {ct}")
    print()
    
    # Try Wiener attack first
    flag = wiener_attack(e, N)
    if flag:
        return
    
    # If Wiener fails, try Fermat factorization
    p, q = fermat_factor(N)
    if p and q:
        flag = decrypt_with_factors(ct, e, p, q)
        print(f"Decrypted: {flag}")
        return
    
    print("All attacks failed")

if __name__ == "__main__":
    main()
