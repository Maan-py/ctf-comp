#!/usr/bin/env python3
"""
Simple RSA Custom Parameter Exploit
Without external dependencies
"""

import socket
import re
import math

def long_to_bytes(n):
    """Convert long to bytes"""
    if n == 0:
        return b'\x00'
    return n.to_bytes((n.bit_length() + 7) // 8, 'big')

def exploit(host='localhost', port=1234):
    # Connect
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))
    
    # Get N
    data = sock.recv(4096).decode()
    print("Received:", data)
    N = int(re.search(r'N:\s*(\d+)', data).group(1))
    
    # Send large bound
    bound = str(2**2000)
    print(f"Sending bound: {bound}")
    sock.send((bound + '\n').encode())
    
    # Get e and ct
    data = sock.recv(4096).decode()
    print("Received:", data)
    e = int(re.search(r'e:\s*(\d+)', data).group(1))
    ct = int(re.search(r'ct:\s*(\d+)', data).group(1))
    
    sock.close()
    
    print(f"N: {N}")
    print(f"e: {e}")
    print(f"ct: {ct}")
    
    # Wiener attack
    print("\nTrying Wiener attack...")
    cf = continued_fraction(e, N)
    convergents_list = convergents(cf)
    
    for k, d in convergents_list:
        if k == 0 or d == 0:
            continue
        if e * d % k == 1:
            try:
                pt = pow(ct, d, N)
                flag = long_to_bytes(pt)
                if b'COMPFEST' in flag or b'{' in flag:
                    print(f"FLAG: {flag}")
                    return flag
            except:
                continue
    
    print("Wiener failed, trying Fermat...")
    
    # Fermat factorization
    a = int(math.sqrt(N)) + 1
    for _ in range(100000):
        b2 = a*a - N
        b = int(math.sqrt(b2))
        if b*b == b2:
            p = a + b
            q = a - b
            phi = (p*p - 1) * (q*q - 1)
            d = pow(e, -1, phi)
            pt = pow(ct, d, N)
            flag = long_to_bytes(pt)
            print(f"FLAG: {flag}")
            return flag
        a += 1
    
    print("All attacks failed")
    return None

def continued_fraction(e, n):
    cf = []
    while n:
        q, r = divmod(e, n)
        cf.append(q)
        e, n = n, r
    return cf

def convergents(cf):
    convergents = []
    for i in range(len(cf)):
        num, den = 1, 0
        for j in range(i, -1, -1):
            num, den = den, num
            num += cf[j] * den
        convergents.append((num, den))
    return convergents

if __name__ == "__main__":
    host = input("Host: ").strip() or 'localhost'
    port = int(input("Port: ").strip() or '1234')
    exploit(host, port)
