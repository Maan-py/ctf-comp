#!/usr/bin/env python3
"""
RSA Custom Parameter Exploit
Challenge: Custom Parameter

The vulnerability is in the bound parameter control.
By choosing a very large bound, we can make d very small,
which makes e very large, enabling Wiener attack.
"""

import socket
import re
from Crypto.Util.number import long_to_bytes
import gmpy2

def connect_and_get_params(host='localhost', port=1234):
    """Connect to server and get N, e, ct"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))
    
    # Get N
    data = sock.recv(4096).decode()
    n_match = re.search(r'N:\s*(\d+)', data)
    if not n_match:
        print("Failed to get N")
        return None, None, None
    
    N = int(n_match.group(1))
    print(f"N = {N}")
    
    # Send very large bound to make d small
    bound = str(2**2000)
    print(f"Sending bound: {bound}")
    sock.send((bound + '\n').encode())
    
    # Get e and ct
    data = sock.recv(4096).decode()
    e_match = re.search(r'e:\s*(\d+)', data)
    ct_match = re.search(r'ct:\s*(\d+)', data)
    
    if not e_match or not ct_match:
        print("Failed to get e or ct")
        return N, None, None
    
    e = int(e_match.group(1))
    ct = int(ct_match.group(1))
    
    print(f"e = {e}")
    print(f"ct = {ct}")
    
    sock.close()
    return N, e, ct

def continued_fraction(e, n):
    """Compute continued fraction expansion of e/n"""
    cf = []
    while n:
        q, r = divmod(e, n)
        cf.append(q)
        e, n = n, r
    return cf

def convergents(cf):
    """Compute convergents from continued fraction"""
    convergents = []
    for i in range(len(cf)):
        num, den = 1, 0
        for j in range(i, -1, -1):
            num, den = den, num
            num += cf[j] * den
        convergents.append((num, den))
    return convergents

def wiener_attack(e, n, ct):
    """Wiener's attack for small private exponent"""
    print("Running Wiener attack...")
    cf = continued_fraction(e, n)
    convergents_list = convergents(cf)
    
    for k, d in convergents_list:
        if k == 0 or d == 0:
            continue
        
        # Check if this d could be the private key
        if e * d % k == 1:
            print(f"Testing d = {d}")
            try:
                pt = pow(ct, d, n)
                flag = long_to_bytes(pt)
                # Check if it looks like a flag
                if b'COMPFEST' in flag or b'flag' in flag.lower() or b'{' in flag:
                    print(f"SUCCESS! Flag: {flag}")
                    return flag
            except:
                continue
    
    print("Wiener attack failed")
    return None

def fermat_factor(n):
    """Fermat factorization for close factors"""
    print("Running Fermat factorization...")
    a = gmpy2.isqrt(n)
    if a * a == n:
        return a, a
    
    a += 1
    count = 0
    while count < 1000000:
        b2 = a * a - n
        b = gmpy2.isqrt(b2)
        if b * b == b2:
            p = a + b
            q = a - b
            print(f"Found factors: p={p}, q={q}")
            return p, q
        a += 1
        count += 1
    
    print("Fermat factorization failed")
    return None, None

def decrypt_with_factors(ct, e, p, q):
    """Decrypt using factors"""
    n = p * q
    # For this challenge: phi = (p²-1)(q²-1)
    phi = (p*p - 1) * (q*q - 1)
    d = pow(e, -1, phi)
    pt = pow(ct, d, n)
    return long_to_bytes(pt)

def main():
    print("=== RSA Custom Parameter Exploit ===")
    print()
    
    # Get server details
    host = input("Server host (default: localhost): ").strip() or 'localhost'
    port = int(input("Server port (default: 1234): ").strip() or '1234')
    
    print(f"\nConnecting to {host}:{port}...")
    
    # Get parameters
    N, e, ct = connect_and_get_params(host, port)
    if N is None:
        print("Failed to connect")
        return
    
    print(f"\nParameters:")
    print(f"N = {N}")
    print(f"e = {e}")
    print(f"ct = {ct}")
    print()
    
    # Try Wiener attack first (most likely to work with large bound)
    flag = wiener_attack(e, N, ct)
    if flag:
        return
    
    # If Wiener fails, try Fermat factorization
    p, q = fermat_factor(N)
    if p and q:
        flag = decrypt_with_factors(ct, e, p, q)
        print(f"Decrypted: {flag}")
        return
    
    print("All attacks failed")

if __name__ == "__main__":
    main()
