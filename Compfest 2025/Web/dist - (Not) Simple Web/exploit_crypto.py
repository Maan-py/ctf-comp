from Crypto.Util.number import long_to_bytes
from math import gcd
import gmpy2

def continued_fraction(e, n):
    """Compute continued fraction expansion of e/n"""
    cf = []
    while n:
        q, r = divmod(e, n)
        cf.append(q)
        e, n = n, r
    return cf

def convergents(cf):
    """Compute convergents from continued fraction"""
    convergents = []
    for i in range(len(cf)):
        num, den = 1, 0
        for j in range(i, -1, -1):
            num, den = den, num
            num += cf[j] * den
        convergents.append((num, den))
    return convergents

def wiener_attack(e, n):
    """Wiener's attack on RSA with small private exponent"""
    cf = continued_fraction(e, n)
    convergents_list = convergents(cf)
    
    for k, d in convergents_list:
        if k == 0:
            continue
        if d == 0:
            continue
            
        # Check if this d could be the private key
        if e * d % k == 1:
            # Try to factor n using this d
            phi = (e * d - 1) // k
            # For standard RSA: phi = (p-1)(q-1)
            # But in this challenge: phi = (p²-1)(q²-1)
            
            # We need to find p and q such that (p²-1)(q²-1) = phi
            # This is more complex, let's try a different approach
            
            # Try to decrypt directly
            try:
                # For small d, we can try direct decryption
                if d < 2**100:  # Reasonable bound for Wiener attack
                    return d
            except:
                continue
    
    return None

def factor_n_with_phi(n, phi):
    """Try to factor n given phi"""
    # For standard RSA: phi = (p-1)(q-1)
    # For this challenge: phi = (p²-1)(q²-1) = (p+1)(p-1)(q+1)(q-1)
    
    # Let's try to find p and q
    # We know: n = p*q
    # And: phi = (p²-1)(q²-1) = (p+1)(p-1)(q+1)(q-1)
    
    # This is more complex, let's try a different approach
    # Since p and q are close (p < q < 2p or q < p < 2q), we can try Fermat's factorization
    
    return fermat_factor(n)

def fermat_factor(n):
    """Fermat's factorization method for numbers with close factors"""
    a = gmpy2.isqrt(n)
    if a * a == n:
        return a, a
    
    a += 1
    while True:
        b2 = a * a - n
        b = gmpy2.isqrt(b2)
        if b * b == b2:
            break
        a += 1
    
    return a + b, a - b

def decrypt_with_small_d(ct, e, n, d):
    """Decrypt using small private exponent"""
    return pow(ct, d, n)

def main():
    print("=== RSA Custom Parameter Exploit ===")
    print()
    
    # We need to interact with the server to get N and e
    # For now, let's create a simulation
    
    print("Strategy:")
    print("1. Connect to server")
    print("2. When asked for bound, enter a very large value (e.g., 2^2000)")
    print("3. This will make d very small, making e very large")
    print("4. Use Wiener attack or similar to recover d")
    print("5. Decrypt the ciphertext")
    print()
    
    print("Example interaction:")
    print("Server: Generating public key....")
    print("Server: N: <some large number>")
    print("You: Enter bound: 2^2000")
    print("Server: Done!")
    print("Server: e: <very large number>")
    print("Server: ct: <ciphertext>")
    print()
    
    print("Then use Wiener attack or try to factor N using Fermat's method")
    print("since p and q are close to each other.")

if __name__ == "__main__":
    main()
