# CTF Web Exploitation Challenge Analysis

## Challenge Overview

This is a web exploitation challenge with a custom HTTP proxy that filters requests to prevent access to a secret page containing the flag.

## Architecture

- **Proxy Server** (`proxy/main.py`): Custom HTTP proxy written in Python
- **Backend Server** (`server/src/main.rs`): Rust server serving static files
- **Flag Location**: Embedded in `secret.html` as base64-encoded text

## Key Vulnerability: URL Encoding Bypass

### The Problem

The proxy has a filter that blocks any request containing "secret" in the URI:

```python
def _filter_route(self, request):
    assert request[1].startswith("/")
    uri = request[1]
    if not (re.match(r"^/\w+\.\w+$", uri) or uri == "/"):
        self._reject(301, "Moved Permanently", "/reject.html")
    if "secret" in uri.lower():  # This is the filter
        self._reject(307, "Temporary Redirect", "/reject.html")
```

### The Vulnerability

The proxy does **NOT** perform URL decoding before checking for "secret" in the URI. This means:

- Normal request: `GET /secret.html` → Blocked (contains "secret")
- Bypass request: `GET /s%65cret.html` → Allowed (contains "s%65cret", not "secret")

Where `%65` is the URL-encoded representation of the letter 'e'.

### Why This Works

1. The proxy receives the raw HTTP request with URL-encoded characters
2. It checks `uri.lower()` for "secret" without decoding
3. `"s%65cret"` does not contain "secret" as a substring
4. The request passes the filter
5. The backend server (Rust) likely decodes the URL properly and serves `secret.html`

## Exploitation Steps

### Step 1: Identify the Bypass

The most effective bypass is URL encoding the 'e' in 'secret':

```
GET /s%65cret.html HTTP/1.1
Host: localhost:8000
Connection: close
```

### Step 2: Extract the Flag

The flag is embedded in `secret.html` as base64-encoded text:

```html
<p style="color: black; position: absolute; left: 0; top: 0;">{{ FLAG }}</p>
```

Where `{{ FLAG }}` is replaced with the base64-encoded flag value.

### Step 3: Decode the Flag

The flag is base64-encoded, so we need to:

1. Extract the base64 string from the response
2. Decode it to get the actual flag

## Alternative Bypass Techniques

### 1. URL Encoding Multiple Characters

```
GET /s%65%63ret.html HTTP/1.1  # 'e' and 'c' encoded
GET /%73ecret.html HTTP/1.1    # 's' encoded
GET /%73%65cret.html HTTP/1.1  # 's' and 'e' encoded
```

### 2. Double URL Encoding

```
GET /s%2565cret.html HTTP/1.1  # %65 (which is 'e') encoded as %2565
```

### 3. Absolute URL with Encoding

```
GET http://localhost:8000/s%65cret.html HTTP/1.1
```

## Testing the Exploit

### Manual Test

```bash
# Start the application
docker-compose up --build

# Test the bypass
python manual_test.py
```

### Automated Test

```bash
# Run comprehensive tests
python exploit.py
```

## Expected Flag Format

Based on the docker-compose.yml, the flag should be in the format:

```
COMPFEST17{...}
```

## Security Lessons

1. **Always URL decode before filtering**: The proxy should decode URLs before applying filters
2. **Input validation**: Consider multiple encoding schemes and bypass techniques
3. **Defense in depth**: Don't rely on a single layer of filtering
4. **Case sensitivity**: Be aware of case variations and encoding differences

## Files Created

- `manual_test.py`: Simple test for the URL encoding bypass
- `exploit.py`: Comprehensive exploit script with multiple bypass techniques
- `test_exploit.py`: Alternative testing approach using requests library
