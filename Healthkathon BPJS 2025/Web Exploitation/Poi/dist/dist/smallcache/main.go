package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io"
	"net"
	"os"
	"strings"
	"sync"
	"time"
)

type Cache struct {
	data  map[string]string
	mutex sync.RWMutex
}

func (c *Cache) Get(k string) (string, bool) {
	c.mutex.RLock()
	v, ok := c.data[k]
	c.mutex.RUnlock()
	return v, ok
}
func (c *Cache) Set(k, v string) {
	c.mutex.Lock()
	c.data[k] = v
	c.mutex.Unlock()
}
func (c *Cache) Clear() {
	c.mutex.Lock()
	for k := range c.data {
		delete(c.data, k)
	}
	c.mutex.Unlock()
}

type Config struct {
	ListenAddr      string   `json:"listen_addr"`
	CacheTTLSeconds int      `json:"cache_ttl_seconds"`
	UpstreamAddr    string   `json:"upstream_addr"`
	SkipPaths       []string `json:"skip_paths"`
}

var (
	cfg            Config
	skipCachePaths = map[string]struct{}{}
)

func loadConfigStrict(path string) error {
	if path == "" {
		return fmt.Errorf("config path is empty")
	}
	b, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("read config failed: %w", err)
	}
	if err := json.Unmarshal(b, &cfg); err != nil {
		return fmt.Errorf("parse config failed: %w", err)
	}
	if strings.TrimSpace(cfg.ListenAddr) == "" {
		return fmt.Errorf("invalid listen_addr: empty")
	}
	if cfg.CacheTTLSeconds <= 0 {
		return fmt.Errorf("invalid cache_ttl_seconds: %d", cfg.CacheTTLSeconds)
	}
	if strings.TrimSpace(cfg.UpstreamAddr) == "" {
		return fmt.Errorf("invalid upstream_addr: empty")
	}
	skipCachePaths = make(map[string]struct{}, len(cfg.SkipPaths))
	for _, p := range cfg.SkipPaths {
		p = strings.TrimSpace(p)
		if p == "" {
			continue
		}
		if !strings.HasPrefix(p, "/") {
			p = "/" + p
		}
		skipCachePaths[p] = struct{}{}
	}
	return nil
}

func normalizedPath(p string) string {
	if i := strings.IndexByte(p, '?'); i >= 0 {
		return p[:i]
	}
	return p
}

func isSkipCachePath(p string) bool {
	np := normalizedPath(p)
	_, skip := skipCachePaths[np]
	return skip
}

func parseStatusCode(statusLine string) int {
	fields := strings.Fields(statusLine)
	if len(fields) >= 2 {
		var code int
		if _, err := fmt.Sscanf(fields[1], "%d", &code); err == nil {
			return code
		}
	}
	return 0
}

func main() {
	const configPath = "config.json"
	if err := loadConfigStrict(configPath); err != nil {
		fmt.Println("[config] fatal:", err.Error())
		os.Exit(1)
	}

	cache := &Cache{data: make(map[string]string), mutex: sync.RWMutex{}}
	go func(c *Cache) {
		ttl := time.Duration(cfg.CacheTTLSeconds) * time.Second
		for {
			time.Sleep(ttl)
			c.Clear()
			fmt.Println("[cache] Cache cleared.")
		}
	}(cache)

	ln, err := net.Listen("tcp", cfg.ListenAddr)
	if err != nil {
		fmt.Println("[init] Listen", cfg.ListenAddr, "failed:", err.Error())
		os.Exit(1)
	}
	defer ln.Close()
	fmt.Printf("[init] HTTP proxy on %s | upstream=%s | ttl=%ds\n",
		cfg.ListenAddr, cfg.UpstreamAddr, cfg.CacheTTLSeconds)

	for {
		conn, err := ln.Accept()
		if err != nil {
			fmt.Println("[accept] Accept failed:", err.Error())
			continue
		}
		go handleConnection(conn, cache)
	}
}

func handleConnection(conn net.Conn, cache *Cache) {
	defer conn.Close()
	r := bufio.NewReader(conn)
	w := bufio.NewWriter(conn)

	up, err := net.Dial("tcp", cfg.UpstreamAddr)
	if err != nil {
		fmt.Println("[upstream] Dial failed:", err.Error())
		return
	}
	defer up.Close()

	for {
		reqLine, err := r.ReadString('\n')
		if err != nil {
			fmt.Println("[protocol] Read request line failed:", err.Error())
			return
		}
		parts := strings.Split(reqLine, " ")
		if len(parts) != 3 {
			fmt.Println("[protocol] Malformed request line:", strings.TrimSpace(reqLine))
			return
		}
		method, path, version := parts[0], parts[1], parts[2]
		fmt.Printf("[request] %s %s %s\n", method, path, strings.TrimSpace(version))

		h := map[string]string{}
		for {
			line, err := r.ReadString('\n')
			if err != nil || line == "\r\n" {
				break
			}
			p := strings.SplitN(line, ":", 2)
			if len(p) != 2 {
				continue
			}
			h[strings.TrimSpace(p[0])] = strings.TrimSpace(p[1])
		}

		key := method + " " + path
		if !isSkipCachePath(path) {
			if resp, ok := cache.Get(key); ok {
				fmt.Printf("[cache] Loaded %s (status 200)\n", key)
				w.WriteString(resp)
				w.Flush()
				return
			}
		}

		resp, rh, statusCode, err := forwardRequest(up, method, path, version, h, r)
		if err != nil {
			fmt.Println("[upstream] Forward failed:", err.Error())
			return
		}

		shouldCache := !isSkipCachePath(path)

		if shouldCache {
			for k, v := range rh {
				if strings.EqualFold(k, "Cache-Control") && strings.Contains(strings.ToLower(v), "no-store") {
					shouldCache = false
					break
				}
			}
		}

		if shouldCache && statusCode >= 400 && statusCode <= 599 {
			shouldCache = false
		}

		if shouldCache {
			cache.Set(key, resp)
			fmt.Printf("[cache] Added %s (status %d)\n", key, statusCode)
		} else {
			fmt.Printf("[cache] Skipped %s (status %d)\n", key, statusCode)
		}

		w.WriteString(resp)
		w.Flush()
	}
}

func forwardRequest(up net.Conn, method, path, version string, h map[string]string, clientR *bufio.Reader) (string, map[string]string, int, error) {
	uw := bufio.NewWriter(up)
	ur := bufio.NewReader(up)

	req := fmt.Sprintf("%s %s %s\r\n", method, path, strings.TrimSpace(version))
	b := strings.Builder{}
	for k, v := range h {
		b.WriteString(fmt.Sprintf("%s: %s\r\n", k, v))
	}
	if _, err := uw.WriteString(req + b.String() + "\r\n"); err != nil {
		return "", nil, 0, fmt.Errorf("write request headers failed: %w", err)
	}

	if cl := h["Content-Length"]; cl != "" {
		var n int
		if _, err := fmt.Sscanf(cl, "%d", &n); err != nil {
			return "", nil, 0, fmt.Errorf("invalid Content-Length in request: %s", cl)
		}
		fmt.Printf("[request] Body bytes=%d\n", n)
		body := make([]byte, n)
		if _, err := io.ReadFull(clientR, body); err != nil {
			return "", nil, 0, fmt.Errorf("read request body failed: %w", err)
		}
		if _, err := uw.Write(body); err != nil {
			return "", nil, 0, fmt.Errorf("send request body failed: %w", err)
		}
	}
	if err := uw.Flush(); err != nil {
		return "", nil, 0, fmt.Errorf("flush to upstream failed: %w", err)
	}

	status, err := ur.ReadString('\n')
	if err != nil {
		return "", nil, 0, fmt.Errorf("read status line failed: %w", err)
	}
	statusCode := parseStatusCode(status)

	rh := map[string]string{}
	for {
		line, err := ur.ReadString('\n')
		if err != nil || line == "\r\n" {
			break
		}
		p := strings.SplitN(line, ":", 2)
		if len(p) != 2 {
			continue
		}
		rh[strings.TrimSpace(p[0])] = strings.TrimSpace(p[1])
	}

	var body strings.Builder
	if cl := rh["Content-Length"]; cl != "" {
		var n int
		if _, err := fmt.Sscanf(cl, "%d", &n); err != nil {
			return "", nil, 0, fmt.Errorf("invalid Content-Length in response: %s", cl)
		}
		buf := make([]byte, n)
		if _, err := io.ReadFull(ur, buf); err != nil {
			return "", nil, 0, fmt.Errorf("read response body failed: %w", err)
		}
		body.Write(buf)
	} else {
		for {
			line, err := ur.ReadString('\n')
			if err != nil {
				if err == io.EOF {
					break
				}
				return "", nil, 0, fmt.Errorf("read response stream failed: %w", err)
			}
			body.WriteString(line)
		}
	}

	resp := status
	for k, v := range rh {
		resp += fmt.Sprintf("%s: %s\r\n", k, v)
	}
	resp += "\r\n" + body.String()
	return resp, rh, statusCode, nil
}