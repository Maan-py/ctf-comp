package com.docxshare.controller;

import com.docxshare.model.DocumentWrapper;
import com.docxshare.model.StoredDoc;
import com.docxshare.model.MetaBundle;
import com.docxshare.security.WAF;
import com.docxshare.util.Base64Utils;
import com.docxshare.util.HashUtils;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletResponse;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InvalidClassException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.StreamCorruptedException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Base64;

@RestController
@RequestMapping("/api")
public class ApiController {

    private final ConcurrentHashMap<String, StoredDoc> storage = new ConcurrentHashMap<>();

    @PostMapping("/upload")
    public Map<String, String> uploadDoc(@RequestBody DocumentWrapper wrapper,
                                         HttpServletResponse response) {
        Map<String, String> result = new HashMap<>();

        if (!Base64Utils.isValidBase64(wrapper.getContent())) {
            result.put("error", "Invalid base64 in content field!");
            return result;
        }
        if (!Base64Utils.isValidBase64(wrapper.getMetadata())) {
            result.put("error", "Invalid base64 in metadata field!");
            return result;
        }

        byte[] metaBytes = Base64.getDecoder().decode(wrapper.getMetadata());
        try (WAF ois = new WAF(new ByteArrayInputStream(metaBytes))) {
            Object ignored = ois.readObject();
        } catch (InvalidClassException ice) {
            result.put("error", "Your action is blocked by WAF");
            return result;
        } catch (StreamCorruptedException sce) {
            result.put("error", "Invalid serialized");
            return result;
        } catch (Exception ex) {
            result.put("error", "Failed to parse metadata");
            return result;
        }

        byte[] contentBytes = Base64.getDecoder().decode(wrapper.getContent());
        try (WAF ois = new WAF(new ByteArrayInputStream(contentBytes))) {
            Object ignored = ois.readObject();
        } catch (InvalidClassException ice) {
            result.put("error", "Your action is blocked by WAF");
            return result;
        } catch (StreamCorruptedException sce) {
        } catch (Exception ex) {
            result.put("error", "Failed to inspect content");
            return result;
        }

        String signature = HashUtils.sha256(wrapper.getContent());
        String uuid = UUID.randomUUID().toString();

        storage.put(uuid, new StoredDoc(wrapper, signature));

        response.addHeader("Set-Cookie", "signature=" + signature + "; HttpOnly; SameSite=Lax; Path=/docs");

        result.put("message", "Uploaded successfully");
        result.put("id", uuid);
        result.put("viewer", "/docs/" + uuid);
        return result;
    }

    @GetMapping("/metadata")
    public Map<String, String> generateMetadata(@RequestParam(defaultValue = "Unknown") String author)
            throws Exception {
        MetaBundle meta = new MetaBundle(
                author,
                java.time.LocalDate.now().toString()
        );

        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(meta);
        oos.close();

        String b64 = Base64.getEncoder().encodeToString(bos.toByteArray());
        return Collections.singletonMap("metadata", b64);
    }

    public StoredDoc getDocument(String uuid) {
        return storage.get(uuid);
    }
}
